<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt Timeline - {{DATE_RANGE}}</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #timeline-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        #header {
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: nowrap;
        }

        h1 {
            font-size: 24px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        #stats {
            color: #888;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
            flex-shrink: 1;
            min-width: 0;
        }

        .control-group {
            display: flex;
            gap: 4px;
            align-items: center;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .actions-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .control-label {
            font-size: 12px;
            color: #888;
        }

        .zoom-btn, .date-nav-btn {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s;
            min-width: 32px;
            white-space: nowrap;
        }

        .date-nav-btn {
            padding: 5px 10px;
        }

        #select-btn {
            min-width: 88px;
        }

        .zoom-btn:hover, .date-nav-btn:hover {
            background: #333;
            border-color: #666;
        }

        .zoom-btn:active, .date-nav-btn:active {
            background: #1a1a1a;
        }

        #date-input {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            width: 130px;
        }

        #date-input:hover {
            border-color: #666;
        }

        #zoom-level-display {
            font-size: 12px;
            color: #888;
            min-width: 50px;
            text-align: center;
        }

        #project-filter {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            min-width: 150px;
            max-width: 150px;
        }

        #project-filter:hover {
            border-color: #666;
        }

        #timeline-scroll-container {
            flex: 1;
            overflow: hidden; /* Prevent SVG content from escaping container */
            overflow-y: auto;
            overflow-x: hidden;
            background: #1a1a1a;
            -webkit-overflow-scrolling: touch; /* Smooth momentum scrolling on iOS/Safari */
            scroll-behavior: smooth;
        }

        #timeline-svg {
            display: block;
            background: #1a1a1a;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            cursor: grab;
        }

        #timeline-svg:active {
            cursor: grabbing;
        }

        .track-line {
            stroke: #333;
            stroke-width: 1;
            fill: none;
        }

        .track-label {
            fill: #666;
            font-size: 11px;
            font-family: monospace;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
        }

        .prompt-dot {
            cursor: pointer;
            transition: r 0.2s, stroke-width 0.2s;
        }

        .prompt-dot.unrated {
            fill: #666;
        }

        .prompt-dot.rating-1, .prompt-dot.rating-2 {
            fill: #e74c3c;
        }

        .prompt-dot.rating-3 {
            fill: #f39c12;
        }

        .prompt-dot.rating-4, .prompt-dot.rating-5 {
            fill: #27ae60;
        }

        .prompt-dot:hover {
            stroke: #fff;
            stroke-width: 2;
        }

        .axis path,
        .axis line {
            stroke: #444;
            stroke-width: 2;
        }

        .axis text {
            fill: #888;
            font-size: 11px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
        }

        /* Grid line styles are set inline based on midnight detection */

        #side-panel {
            width: 0;
            background: #242424;
            border-left: 1px solid #333;
            overflow-y: auto;
            transition: width 0.3s;
            flex-shrink: 0;
        }

        #side-panel.active {
            width: 450px;
        }

        .panel-content {
            padding: 30px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #side-panel.active .panel-content {
            opacity: 1;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 24px;
        }

        .close-btn:hover {
            color: #fff;
        }

        .prompt-id {
            color: #666;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .prompt-time {
            color: #888;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .rating-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .rating-star {
            font-size: 28px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }

        .rating-star:hover {
            transform: scale(1.2);
        }

        .rating-star.filled {
            color: #f39c12;
        }

        .rating-star.empty {
            color: #444;
        }

        .prompt-text {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 6px;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 15px;
            white-space: pre-wrap;
        }

        .prompt-meta {
            color: #888;
            font-size: 13px;
            margin-top: 15px;
        }

        .prompt-note {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            border-left: 3px solid #f39c12;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .save-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #27ae60;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 2000;
        }

        .save-status.show {
            opacity: 1;
        }

        .tooltip-d3 {
            position: absolute;
            background: #2a2a2a;
            border: 1px solid #444;
            padding: 10px 14px;
            border-radius: 4px;
            font-size: 13px;
            max-width: 250px;
            max-height: 320px;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tooltip-time {
            color: #888;
            font-size: 11px;
            margin-bottom: 6px;
        }

        .tooltip-text {
            color: #e0e0e0;
            line-height: 1.5;
            max-height: 280px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 13;
            -webkit-box-orient: vertical;
        }

        .zoom-help {
            font-size: 11px;
            color: #666;
            font-style: italic;
            margin-top: 5px;
        }

        .selection-rect {
            fill: rgba(59, 130, 246, 0.1);
            stroke: #3b82f6;
            stroke-width: 2;
            stroke-dasharray: 3, 6;
            pointer-events: none;
        }

        .prompt-dot.selected {
            fill: #f97316 !important;
            opacity: 1 !important;
            stroke: #ea580c;
            stroke-width: 2;
        }

        #select-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        .theater-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 10000;
            display: none;
        }

        .theater-mode.active {
            display: block;
        }

        .theater-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10001;
        }

        .theater-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .theater-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theater-timeline {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 25%;
        }

        .theater-prompt-display {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            max-width: 80%;
            max-height: 65%;
            text-align: center;
            color: white;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .theater-prompt-time {
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 20px rgba(0, 0, 0, 0.8);
        }

        .theater-prompt-project {
            font-size: 20px;
            font-weight: 600;
            color: #f97316;
            text-shadow: 0 2px 10px rgba(249, 115, 22, 0.5);
        }

        .theater-prompt-text {
            font-size: 28px;
            font-weight: 300;
            line-height: 1.5;
            text-shadow: 0 2px 20px rgba(0, 0, 0, 0.8);
            overflow-y: auto;
            max-height: 100%;
            padding-right: 10px;
        }

        .theater-prompt-text::-webkit-scrollbar {
            width: 8px;
        }

        .theater-prompt-text::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .theater-prompt-text::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .theater-prompt-text::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .theater-prompt-meta {
            font-size: 16px;
            color: #888;
            font-weight: 400;
        }

        .theater-rating {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .theater-rating-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .theater-rating-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }

        .theater-rating-btn.active {
            background: #f97316;
            border-color: #f97316;
        }

        .theater-progress {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
        }

        .floating-note {
            position: absolute;
            font-size: 48px;
            animation: floatUp 2s ease-out forwards;
            pointer-events: none;
            text-shadow: 0 0 20px currentColor;
        }

        @keyframes floatUp {
            0% {
                opacity: 0;
                transform: translateY(0) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translateY(-100px) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translateY(-200px) scale(0.8);
            }
        }

        .crawl-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 10000;
            display: none;
            overflow: hidden;
        }

        .crawl-mode.active {
            display: block;
        }

        #starfield {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.6;
        }

        .crawl-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            pointer-events: auto;
            scroll-behavior: smooth;
            z-index: 1;
            /* reverted padding to avoid layout shift */
        }

        .crawl-text {
            position: relative;
            margin: 10vh auto 20vh;
            width: 70%;
            max-width: 1000px;
            padding-left: 140px; /* nudge content right away from the clock */
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            font-size: 180%;
            font-weight: 700;
            line-height: 1.6;
            letter-spacing: 2px;
            color: #00ff41;
            text-align: center;
            text-shadow:
                0 0 10px rgba(0, 255, 65, 0.8),
                0 0 20px rgba(0, 255, 65, 0.5),
                0 0 30px rgba(0, 255, 65, 0.3),
                2px 2px 4px rgba(0, 0, 0, 0.9);
        }

        /* Keyframes kept for legacy auto-crawl, not used in scroll mode */
        @keyframes crawl {
            0% { opacity: 1; }
            100% { opacity: 1; }
        }

        .crawl-clock {
            position: fixed;
            top: 50%;
            left: 40px;
            transform: translateY(-50%);
            font-family: 'Courier New', monospace;
            font-size: 48px;
            font-weight: bold;
            color: #00ff41;
            text-shadow:
                0 0 10px rgba(0, 255, 65, 0.8),
                0 0 20px rgba(0, 255, 65, 0.6);
            z-index: 10001;
        }

        .crawl-prompt {
            margin-bottom: 120px;
            padding: 40px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .crawl-prompt:hover {
            transform: scale(1.1);
            color: #ffff00;
            text-shadow:
                0 0 15px rgba(255, 255, 0, 1),
                0 0 30px rgba(255, 255, 0, 0.7),
                0 0 45px rgba(255, 255, 0, 0.5);
        }

        .crawl-prompt-meta {
            font-size: 60%;
            color: #00ffff;
            margin-bottom: 25px;
            font-weight: 700;
            text-align: center;
            letter-spacing: 4px;
            text-shadow:
                0 0 10px rgba(0, 255, 255, 0.8),
                0 0 20px rgba(0, 255, 255, 0.5),
                2px 2px 4px rgba(0, 0, 0, 0.9);
        }

        .crawl-prompt-text {
            font-size: 100%;
            line-height: 1.5;
            text-transform: none;
        }

        .crawl-prompt.highlighted {
            background: rgba(255, 255, 0, 0.1);
            border-left: 4px solid #ffff00;
            padding-left: 36px;
        }

        .crawl-prompt-rating {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .crawl-rating-star {
            font-size: 32px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }

        .crawl-rating-star:hover {
            transform: scale(1.3);
            filter: drop-shadow(0 0 10px currentColor);
        }

        .crawl-rating-star.filled {
            color: #ffd700;
        }

        .crawl-rating-star.empty {
            color: #444;
        }


        /* Calendar view styles */
        .calendar-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            z-index: 10000;
            display: none;
            overflow: auto;
            padding: 40px;
        }

        .calendar-view.active {
            display: block;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .calendar-title {
            font-size: 32px;
            font-weight: bold;
            color: #e0e0e0;
        }

        .calendar-close {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .calendar-close:hover {
            background: #333;
        }

        .calendar-nav {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
        }

        .calendar-nav button {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .calendar-nav button:hover {
            background: #333;
        }

        .calendar-nav span {
            font-size: 24px;
            font-weight: bold;
            color: #e0e0e0;
            min-width: 200px;
            text-align: center;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .calendar-day-header {
            text-align: center;
            padding: 10px;
            font-weight: bold;
            color: #888;
            font-size: 14px;
        }

        .calendar-day {
            aspect-ratio: 1;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .calendar-day:hover {
            border-color: #666;
            transform: scale(1.05);
            z-index: 1;
        }

        .calendar-day.other-month {
            opacity: 0.3;
        }

        .calendar-day.today {
            border-color: #f97316;
            border-width: 2px;
        }

        .calendar-day-number {
            font-size: 16px;
            font-weight: bold;
            color: #e0e0e0;
        }

        .calendar-day-count {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .calendar-legend {
            margin-top: 30px;
            text-align: center;
            color: #888;
            font-size: 14px;
        }

        .calendar-legend-items {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }

        .calendar-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .calendar-legend-box {
            width: 30px;
            height: 20px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="timeline-container">
        <div id="header">
            <div class="header-row">
                <h1>Prompt Timeline</h1>
                <div class="controls">
                    <button class="zoom-btn" onclick="showCalendar()" title="Calendar view">📅</button>
                    <div class="control-group">
                        <span class="control-label">Date:</span>
                        <button class="date-nav-btn" onclick="changeDate(-1)" title="Previous day">←</button>
                        <input type="date" id="date-input" value="{{CURRENT_DATE}}" onchange="onDateChange(this.value)">
                        <button class="date-nav-btn" onclick="changeDate(1)" title="Next day">→</button>
                    </div>
                    <div class="control-group">
                        <span class="control-label">Zoom:</span>
                        <button class="zoom-btn" onclick="zoomOut()" title="Zoom out">−</button>
                        <span id="zoom-level-display">100%</span>
                        <button class="zoom-btn" onclick="zoomIn()" title="Zoom in">+</button>
                    </div>
                    <button class="zoom-btn" id="reorder-btn" onclick="refreshTimeline()" title="Rerank projects by activity in visible range">
                        Rerank
                        <span id="project-count-badge" style="margin-left: 4px; color: white; border-radius: 10px; padding: 2px 6px; font-size: 10px; font-weight: bold;"></span>
                    </button>
                    <button class="zoom-btn" id="select-btn" onclick="toggleSelection()" title="Select prompts (drag to select) • Press S">⬚ Select</button>
                    <div class="actions-group">
                        <button class="zoom-btn" id="export-btn" onclick="exportSelected()" title="Export selected to CSV" style="display:none;">📥 CSV</button>
                        <button class="zoom-btn" id="animate-theater-btn" onclick="animateTheater()" title="Theater mode - 2 minute animation" style="display:none;">🎬 Theater</button>
                        <button class="zoom-btn" id="animate-10x-btn" onclick="animate10x()" title="Quick preview - 10x speed" style="display:none;">▶ 10x</button>
                        <button class="zoom-btn" id="animate-crawl-btn" onclick="animateCrawl()" title="Opening crawl - scrolling text" style="display:none;">⭐ Crawl</button>
                        <span id="selection-count" style="display:none; margin-left: 8px; color: #888; font-size: 12px;"></span>
                    </div>
                </div>
            </div>
            <div class="header-row" style="margin-top: 5px;">
                <div class="controls">
                    <div class="control-group">
                        <span class="control-label" style="color: #888;">Viewing:</span>
                        <span id="visible-range-display" style="color: #aaa; font-size: 12px; font-family: monospace; white-space: nowrap;">Loading...</span>
                    </div>
                    <div class="control-group">
                        <span class="control-label">Project:</span>
                        <select id="project-filter" onchange="filterByProject(this.value)">
                            <option value="">All Projects</option>
                        </select>
                    </div>
                </div>
            </div>
            <div id="stats">{{STATS}}</div>
            <div class="zoom-help">Vertical scroll through projects • Click and drag to pan • Pinch to zoom • Click dots for details • Keys: S (select) = (zoom in) - (zoom out)</div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background: #27ae60"></div>
                    <span>High (4-5 ★)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #f39c12"></div>
                    <span>Medium (3 ★)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #e74c3c"></div>
                    <span>Low (1-2 ★)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #666"></div>
                    <span>Unrated</span>
                </div>
            </div>
        </div>
        <div id="timeline-scroll-container">
            <svg id="timeline-svg"></svg>
        </div>
    </div>

    <div id="side-panel">
        <div class="panel-content">
            <div class="panel-header">
                <div></div>
                <button class="close-btn" onclick="closePanel()">&times;</button>
            </div>
            <div id="panel-body"></div>
        </div>
    </div>

    <div class="tooltip-d3" id="tooltip"></div>
    <div id="save-status" class="save-status">Rating saved ✓</div>

    <div id="theater-mode" class="theater-mode" onclick="event.target.id === 'theater-mode' && exitTheaterMode()">
        <div class="theater-controls">
            <button class="theater-btn" onclick="exitTheaterMode()">← Go Back</button>
        </div>
        <div class="theater-prompt-display" id="theater-prompt">
            <div class="theater-prompt-time" id="theater-time"></div>
            <div class="theater-prompt-project" id="theater-project"></div>
            <div class="theater-prompt-text" id="theater-text"></div>
            <div class="theater-rating" id="theater-rating">
                <button class="theater-rating-btn" onclick="rateTheaterPrompt(1)">1</button>
                <button class="theater-rating-btn" onclick="rateTheaterPrompt(2)">2</button>
                <button class="theater-rating-btn" onclick="rateTheaterPrompt(3)">3</button>
                <button class="theater-rating-btn" onclick="rateTheaterPrompt(4)">4</button>
                <button class="theater-rating-btn" onclick="rateTheaterPrompt(5)">5</button>
            </div>
        </div>
        <div class="theater-progress" id="theater-progress"></div>
        <div class="theater-timeline" id="theater-timeline"></div>
    </div>

    <div id="crawl-mode" class="crawl-mode">
        <canvas id="starfield"></canvas>
        <div class="theater-controls">
            <button class="theater-btn" onclick="exitCrawlMode()">← Back</button>
        </div>
        <div class="crawl-clock" id="crawl-clock"></div>
        <div class="crawl-container">
            <div class="crawl-text" id="crawl-text"></div>
        </div>
    </div>

    <div id="calendar-view" class="calendar-view">
        <div class="calendar-header">
            <h2 class="calendar-title">Prompt Calendar</h2>
            <button class="calendar-close" onclick="closeCalendar()">✕ Close</button>
        </div>
        <div class="calendar-nav">
            <button onclick="changeCalendarMonth(-1)">← Previous</button>
            <span id="calendar-month-year"></span>
            <button onclick="changeCalendarMonth(1)">Next →</button>
        </div>
        <div class="calendar-grid" id="calendar-grid"></div>
        <div class="calendar-legend">
            <div class="legend-title">Prompt Density</div>
            <div class="legend-scale">
                <span>Low</span>
                <div class="legend-gradient"></div>
                <span>High</span>
            </div>
        </div>
    </div>

    <script>
        let prompts = {{PROMPTS_DATA}};
        let currentPrompt = null;
        let currentDate = '{{CURRENT_DATE}}';
        let currentProjectFilter = '';
        let selectionMode = false;
        let selectedPrompts = new Set();
        let brush;
        let theaterSvg, theaterG, theaterContentGroup;
        let animationRunning = false;
        let theaterPrompts = [];  // Prompts being shown in theater mode
        let theaterCurrentIndex = 0;  // Current prompt index in theater mode
        let theaterDuration = 120000;  // Duration for theater animation (default 2 minutes)
        let autoRerankTimeout = null;  // Timeout for auto-rerank after inactivity

        // D3 visualization variables
        let svg, g, contentGroup, xScale, yScale, zoom, xAxis;
        const margin = {top: 50, right: 40, bottom: 60, left: 150};

        // ===== VIEWPORT STATE MANAGER - Single Source of Truth =====
        const ViewportState = {
            transform: null,
            scrollTop: 0,
            savedState: null,

            save() {
                if (!svg) return;
                const container = document.getElementById('timeline-scroll-container');
                this.savedState = {
                    transform: d3.zoomTransform(svg.node()),
                    scrollTop: container ? container.scrollTop : 0
                };
            },

            restore() {
                if (!this.savedState || !svg) return;
                const container = document.getElementById('timeline-scroll-container');

                // Apply transform without triggering events
                svg.node().__zoom = this.savedState.transform;
                if (container) {
                    container.scrollTop = this.savedState.scrollTop;
                }

                // Update visualization with new transform
                zoomed({ transform: this.savedState.transform });
            },

            get() {
                if (!svg) return null;
                const container = document.getElementById('timeline-scroll-container');
                return {
                    transform: d3.zoomTransform(svg.node()),
                    scrollTop: container ? container.scrollTop : 0
                };
            }
        };

        // ===== MODE MANAGER - Controls Interaction Modes =====
        const MODES = {
            NORMAL: 'normal',
            SELECTION: 'selection',
            THEATER: 'theater',
            CRAWL: 'crawl'
        };

        let currentMode = MODES.NORMAL;

        function setMode(newMode) {
            if (currentMode === newMode) return;

            // Exit current mode
            switch(currentMode) {
                case MODES.SELECTION:
                    disableBrushMode();
                    break;
                case MODES.THEATER:
                case MODES.CRAWL:
                    // Theater/crawl cleanup handled by their own functions
                    break;
            }

            currentMode = newMode;

            // Enter new mode
            switch(newMode) {
                case MODES.NORMAL:
                    enableNormalMode();
                    break;
                case MODES.SELECTION:
                    enableBrushMode();
                    break;
                case MODES.THEATER:
                case MODES.CRAWL:
                    // Theater/crawl setup handled by their own functions
                    break;
            }

            // DON'T save/restore viewport on mode change - just freeze it!
            // Viewport only changes when user explicitly pans/zooms
        }

        function enableNormalMode() {
            // Normal mode is the default - zoom/pan enabled
            // Nothing special to do, zoom is always active unless we disable it
        }

        function enableBrushMode() {
            if (!svg || !contentGroup) return;

            const container = document.getElementById('timeline-scroll-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            brush = d3.brush()
                .extent([[0, 0], [innerWidth, innerHeight]])
                .on('end', brushEnded);

            contentGroup.append('g')
                .attr('class', 'brush')
                .call(brush);

            // Disable zoom by removing event listeners (NOT by calling svg.call())
            svg.on('.zoom', null);
        }

        function disableBrushMode() {
            if (!contentGroup) return;

            contentGroup.select('.brush').remove();
            brush = null;

            // Re-enable zoom by re-attaching to the EXISTING zoom behavior
            // CRITICAL: Never call svg.call(zoom) again - it's already attached from initTimeline
            if (zoom) {
                svg.on('mousedown.zoom', zoom);
                svg.on('dblclick.zoom', zoom);
                svg.on('touchstart.zoom', zoom);
                svg.on('wheel.zoom', zoom);
            }
        }

        // All prompts loaded at once - no lazy loading

        // Group prompts by project
        const projectGroups = {};
        const projectColors = {};
        const colorScale = d3.scaleOrdinal(d3.schemeTableau10);

        prompts.forEach(p => {
            const project = p.project || 'Unknown';
            if (!projectGroups[project]) {
                projectGroups[project] = [];
                projectColors[project] = colorScale(project);
            }
            projectGroups[project].push(p);
        });

        const allProjects = Object.keys(projectGroups).sort();

        // Show all projects (no automatic filtering)
        const projectCounts = allProjects.map(project => ({
            project: project,
            count: projectGroups[project].length
        }));
        projectCounts.sort((a, b) => {
            if (b.count !== a.count) return b.count - a.count;
            return a.project.localeCompare(b.project);
        });

        // Show all projects ordered by prompt count (most to least)
        let projects = projectCounts.map(pc => pc.project);
        let isFiltered = false;

        // Populate project filter
        const projectFilter = document.getElementById('project-filter');

        function populateProjectFilter() {
            projectFilter.innerHTML = '<option value="">All Projects</option>';
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project;
                const shortName = project.split('/').pop() || project;
                option.textContent = shortName;
                option.title = project; // Show full path on hover
                projectFilter.appendChild(option);
            });
        }

        populateProjectFilter();

        function initTimeline(skipInitialTransform = false) {
            const container = document.getElementById('timeline-scroll-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Calculate dimensions first to get virtualHeight
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const visibleProjects = currentProjectFilter ?
                [currentProjectFilter] : projects;

            // Dynamic spacing: use full viewport height, with minimum spacing for many projects
            const minProjectHeight = 35; // Minimum height for 15 projects
            const maxProjectHeight = innerHeight / Math.max(1, visibleProjects.length); // Fill viewport
            const projectHeight = Math.max(minProjectHeight, maxProjectHeight);
            const virtualHeight = visibleProjects.length * projectHeight;

            // Set SVG to virtual height to enable scrolling
            const svgHeight = Math.max(virtualHeight + margin.top + margin.bottom, height);

            svg = d3.select('#timeline-svg')
                .attr('width', width)
                .attr('height', svgHeight);

            // Clear any existing content
            svg.selectAll('*').remove();

            // Create main group with margins
            g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Add clip path to prevent dots from drawing over axis
            // Start much higher (y=-100) to accommodate any transforms during panning
            svg.append('defs')
                .append('clipPath')
                .attr('id', 'timeline-clip')
                .append('rect')
                .attr('x', 0)
                .attr('y', -100)
                .attr('width', innerWidth)
                .attr('height', innerHeight + 100);

            // Create content group WITHOUT clipping - clipping during transforms causes issues
            contentGroup = g.append('g');

            // Time scale (X axis) - domain covers all prompts for infinite panning
            const [year, month, day] = currentDate.split('-').map(Number);
            const dayStart = new Date(year, month - 1, day, 0, 0, 0, 0);

            // Calculate domain from all prompts data
            let minTime, maxTime;
            if (prompts.length > 0) {
                const timestamps = prompts.map(p => p.timestamp);
                minTime = new Date(Math.min(...timestamps));
                maxTime = new Date(Math.max(...timestamps));
                // Add 1 day buffer on each side
                minTime = new Date(minTime.getTime() - (24 * 60 * 60 * 1000));
                maxTime = new Date(maxTime.getTime() + (24 * 60 * 60 * 1000));
            } else {
                // Fallback if no prompts
                minTime = new Date(dayStart.getTime() - (7 * 24 * 60 * 60 * 1000));
                maxTime = new Date(dayStart.getTime() + (1 * 24 * 60 * 60 * 1000));
            }

            // Calculate range width based on time span
            const timeSpan = maxTime.getTime() - minTime.getTime();
            const daySpan = timeSpan / (24 * 60 * 60 * 1000);
            const rangeWidth = innerWidth * Math.max(2, daySpan / 3); // At least 2x screen width

            xScale = d3.scaleTime()
                .domain([minTime, maxTime])
                .range([0, rangeWidth]);

            // Update clip path width to match the full range width (not just viewport)
            svg.select('#timeline-clip rect')
                .attr('width', rangeWidth)
                .attr('height', virtualHeight + 100);

            // Set initial transform to show from 11pm previous day to 1am next day (26 hour window)
            const prevDay = new Date(dayStart.getTime() - (24 * 60 * 60 * 1000)); // Previous day midnight
            const viewStart = new Date(prevDay.getTime() + (23 * 60 * 60 * 1000)); // 11pm previous day
            const viewEnd = new Date(dayStart.getTime() + (25 * 60 * 60 * 1000)); // 1am next day (25 hours after current day midnight)

            // Calculate scale to fit 26 hours in viewport
            const viewDuration = viewEnd.getTime() - viewStart.getTime(); // 26 hours in ms
            const viewStartX = xScale(viewStart);
            const viewEndX = xScale(viewEnd);
            const viewWidthInScale = viewEndX - viewStartX;
            const initialScale = innerWidth / viewWidthInScale; // Scale to fit 26 hours
            const initialX = -viewStartX * initialScale; // Translate to show viewStart at left edge

            // Project scale (Y axis) - already calculated above
            yScale = d3.scaleBand()
                .domain(visibleProjects)
                .range([15, virtualHeight])  // Start 15px below to avoid clipping first project
                .padding(0.3);

            // State for smooth trackpad interaction
            let currentTransform = d3.zoomIdentity;

            // Add zoom behavior for pinch-to-zoom and Ctrl+horizontal panning
            zoom = d3.zoom()
                .scaleExtent([0.5, 100])
                .filter(function(event) {
                    if (event.type === 'wheel') {
                        // Allow wheel events for zoom and panning
                        return true;
                    }
                    // Allow programmatic zoom
                    return !event.sourceEvent;
                })
                .wheelDelta(function(event) {
                    // Custom wheel delta to handle Ctrl+horizontal scroll as panning
                    if (event.ctrlKey && Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
                        // Ctrl+horizontal scroll: pan only, no zoom
                        // Return 0 for scale to prevent zooming
                        return 0;
                    }
                    // Default zoom behavior - 3x faster for better responsiveness
                    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * 3;
                })
                .on('zoom', function(event) {
                    // Handle Ctrl+horizontal scroll as panning
                    if (event.sourceEvent && event.sourceEvent.type === 'wheel' &&
                        event.sourceEvent.ctrlKey && Math.abs(event.sourceEvent.deltaX) > Math.abs(event.sourceEvent.deltaY)) {
                        // Manual pan from horizontal deltaX
                        const panAmount = -event.sourceEvent.deltaX * 2; // Scale for smooth panning
                        currentTransform = d3.zoomIdentity
                            .translate(currentTransform.x + panAmount, 0)
                            .scale(currentTransform.k);
                    } else {
                        // Normal zoom/pan behavior
                        currentTransform = d3.zoomIdentity
                            .translate(event.transform.x, 0)
                            .scale(event.transform.k);
                    }
                    zoomed({ transform: currentTransform });
                });

            // Add drag behavior for panning - works great with trackpad!
            const drag = d3.drag()
                .filter(function(event) {
                    // Allow all mouse/touch drag events
                    return !event.ctrlKey && event.button !== 2;
                })
                .on('start', function(event) {
                    // Store starting position
                    const container = document.getElementById('timeline-scroll-container');
                    this.dragStart = {
                        x: event.x,
                        y: event.y,
                        transformX: currentTransform.x,
                        scrollTop: container.scrollTop
                    };
                })
                .on('drag', function(event) {
                    if (!this.dragStart) return;

                    // Calculate horizontal pan amount
                    const dx = event.x - this.dragStart.x;
                    const newX = this.dragStart.transformX + dx;

                    // Apply constraints for horizontal
                    const maxPan = innerWidth * 0.1;
                    const contentWidth = innerWidth * currentTransform.k;
                    const minPan = innerWidth - contentWidth - (innerWidth * 0.1);
                    const constrainedX = Math.max(minPan, Math.min(maxPan, newX));

                    currentTransform = d3.zoomIdentity
                        .translate(constrainedX, 0)
                        .scale(currentTransform.k);

                    // Apply transform immediately
                    zoomed({ transform: currentTransform });

                    // Calculate vertical scroll amount
                    const dy = event.y - this.dragStart.y;
                    const container = document.getElementById('timeline-scroll-container');
                    container.scrollTop = this.dragStart.scrollTop - dy;
                })
                .on('end', function(event) {
                    delete this.dragStart;
                });

            // Apply zoom and drag
            svg.call(zoom);
            svg.call(drag);

            // If we skipped initial transform, the caller will restore the saved transform
            // Do nothing here to avoid triggering zoom events

            // Add grid lines for all hours in the wide domain (inside clipped area)
            const gridGroup = contentGroup.append('g')
                .attr('class', 'grid');

            // Create grid lines for entire time domain
            const gridStartDate = new Date(minTime);
            const gridEndDate = new Date(maxTime);

            // Generate hourly grid lines for entire range
            let currentGridDate = new Date(gridStartDate);
            currentGridDate.setMinutes(0, 0, 0); // Start at hour boundary

            while (currentGridDate <= gridEndDate) {
                const isToday = currentGridDate.toDateString() === new Date(year, month - 1, day).toDateString();
                const isMidnight = currentGridDate.getHours() === 0;

                gridGroup.append('line')
                    .attr('data-timestamp', currentGridDate.getTime())
                    .attr('x1', xScale(currentGridDate))
                    .attr('x2', xScale(currentGridDate))
                    .attr('y1', 0)
                    .attr('y2', virtualHeight)
                    .attr('stroke', isMidnight ? '#ffffff' : '#2a2a2a')
                    .attr('stroke-opacity', isMidnight ? 0.5 : (isToday ? 0.3 : 0.2))
                    .attr('stroke-width', isMidnight ? 4 : 1)
                    .attr('stroke-dasharray', isMidnight ? '10,5' : null);

                currentGridDate.setHours(currentGridDate.getHours() + 1);
            }

            // Add "now" line (current time indicator) inside clipped area - RED
            const now = new Date();
            const nowLine = contentGroup.append('line')
                .attr('class', 'now-line')
                .attr('x1', xScale(now))
                .attr('x2', xScale(now))
                .attr('y1', 0)
                .attr('y2', virtualHeight)
                .attr('stroke', '#ff4444')
                .attr('stroke-width', 2)
                .attr('stroke-opacity', 0.8)
                .attr('stroke-dasharray', '5,5');

            // Add X axis with time ticks at top (outside clipped area)
            xAxis = g.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,0)`)
                .call(d3.axisTop(xScale)
                    .ticks(d3.timeHour.every(2))
                    .tickFormat(d3.timeFormat('%H:%M')));

            // Add project tracks (inside clipped area)
            visibleProjects.forEach(project => {
                const y = yScale(project) + yScale.bandwidth() / 2;

                // Track line
                contentGroup.append('line')
                    .attr('class', 'track-line')
                    .attr('x1', 0)
                    .attr('x2', innerWidth)
                    .attr('y1', y)
                    .attr('y2', y)
                    .attr('stroke', projectColors[project])
                    .attr('stroke-opacity', 0.3);

                // Track label - simple gray text
                const labelText = project.split('/').pop() || project;
                const labelWidth = 140;
                const labelHeight = yScale.bandwidth();

                const labelGroup = g.append('foreignObject')
                    .attr('x', -labelWidth - 5)
                    .attr('y', y - labelHeight / 2)
                    .attr('width', labelWidth)
                    .attr('height', labelHeight);

                labelGroup.append('xhtml:div')
                    .style('color', '#888')
                    .style('font-size', '11px')
                    .style('text-align', 'right')
                    .style('padding-right', '5px')
                    .style('white-space', 'nowrap')
                    .style('overflow', 'hidden')
                    .style('text-overflow', 'ellipsis')
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('justify-content', 'flex-end')
                    .style('height', '100%')
                    .text(labelText)
                    .attr('title', project);
            });

            // Add prompts
            renderPrompts();
            updateZoomDisplay();
            updateHiddenProjectsBadge();

            // Set initial position to show 26-hour window (11pm yesterday to 1am today)
            // Only apply if not skipping (i.e., on first load, not when reordering)
            if (!skipInitialTransform) {
                svg.call(zoom.transform, d3.zoomIdentity.translate(initialX, 0).scale(initialScale));
            }
        }

        function renderPrompts() {
            const visibleProjects = currentProjectFilter ?
                [currentProjectFilter] : projects;

            const visiblePrompts = prompts.filter(p => {
                const project = p.project || 'Unknown';
                return visibleProjects.includes(project);
            });

            // Calculate dot radius based on prompt length
            const maxLength = d3.max(visiblePrompts, d => d.display.length) || 1000;
            const radiusScale = d3.scaleSqrt()
                .domain([0, maxLength])
                .range([4, 20]);

            const dots = contentGroup.selectAll('.prompt-dot')
                .data(visiblePrompts, d => d.id);

            // Remove old dots
            dots.exit()
                .transition()
                .duration(300)
                .attr('r', 0)
                .remove();

            // Update existing dots
            dots.transition()
                .duration(300)
                .attr('cx', d => xScale(new Date(d.timestamp)))
                .attr('cy', d => {
                    const project = d.project || 'Unknown';
                    return yScale(project) + yScale.bandwidth() / 2;
                })
                .attr('r', d => radiusScale(d.display.length));

            // Add new dots
            const newDots = dots.enter()
                .append('circle')
                .attr('class', d => {
                    let classes = 'prompt-dot';
                    if (d.rating === null) {
                        classes += ' unrated';
                    } else {
                        classes += ` rating-${d.rating}`;
                    }
                    return classes;
                })
                .attr('cx', d => xScale(new Date(d.timestamp)))
                .attr('cy', d => {
                    const project = d.project || 'Unknown';
                    return yScale(project) + yScale.bandwidth() / 2;
                })
                .attr('r', 0)
                .style('opacity', 0.8)
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip)
                .on('click', function(event, d) {
                    // Don't open panel if in selection mode
                    if (!selectionMode) {
                        showPromptInTheater(d);
                    }
                });

            newDots.transition()
                .duration(300)
                .attr('r', d => radiusScale(d.display.length));
        }

        function zoomed(event) {
            // Only apply X-axis transform (horizontal zoom/pan)
            const transform = d3.zoomIdentity
                .translate(event.transform.x, 0)
                .scale(event.transform.k);

            const newXScale = transform.rescaleX(xScale);
            const zoomLevel = transform.k;

            // Adaptive tick interval and format based on zoom level
            let tickInterval, tickFormat;
            if (zoomLevel < 1) {
                // Zoomed out: 4-hour intervals
                tickInterval = d3.timeHour.every(4);
                tickFormat = d3.timeFormat('%H:%M');
            } else if (zoomLevel < 2) {
                // Normal view: 2-hour intervals
                tickInterval = d3.timeHour.every(2);
                tickFormat = d3.timeFormat('%H:%M');
            } else if (zoomLevel < 5) {
                // Zoomed in: hourly
                tickInterval = d3.timeHour.every(1);
                tickFormat = d3.timeFormat('%H:%M');
            } else if (zoomLevel < 15) {
                // More zoomed: 30-minute intervals
                tickInterval = d3.timeMinute.every(30);
                tickFormat = d3.timeFormat('%H:%M');
            } else if (zoomLevel < 40) {
                // Very zoomed: 10-minute intervals
                tickInterval = d3.timeMinute.every(10);
                tickFormat = d3.timeFormat('%H:%M');
            } else {
                // Extremely zoomed: 5-minute intervals with seconds
                tickInterval = d3.timeMinute.every(5);
                tickFormat = d3.timeFormat('%H:%M:%S');
            }

            // Update axis with adaptive ticks
            xAxis.call(d3.axisTop(newXScale)
                .ticks(tickInterval)
                .tickFormat(tickFormat));

            // Update dots X position and opacity based on viewport visibility
            const container = document.getElementById('timeline-scroll-container');
            const viewportWidth = container.clientWidth - margin.left - margin.right;

            contentGroup.selectAll('.prompt-dot')
                .attr('cx', d => newXScale(new Date(d.timestamp)))
                .attr('opacity', function(d) {
                    const cx = newXScale(new Date(d.timestamp));
                    // Full opacity if in viewport, faded if outside
                    if (cx >= 0 && cx <= viewportWidth) {
                        return 1;
                    } else {
                        return 0.15;
                    }
                });

            // Update now line X position
            const now = new Date();
            contentGroup.selectAll('.now-line')
                .attr('x1', newXScale(now))
                .attr('x2', newXScale(now));

            // Update grid lines X position using stored timestamps
            contentGroup.selectAll('.grid line')
                .attr('x1', function() {
                    const timestamp = parseInt(d3.select(this).attr('data-timestamp'));
                    return newXScale(new Date(timestamp));
                })
                .attr('x2', function() {
                    const timestamp = parseInt(d3.select(this).attr('data-timestamp'));
                    return newXScale(new Date(timestamp));
                });

            // Update track lines X position
            contentGroup.selectAll('.track-line')
                .attr('x1', 0)
                .attr('x2', function() {
                    const container = document.getElementById('timeline-scroll-container');
                    const width = container.clientWidth;
                    return width - margin.left - margin.right;
                });

            // Update zoom display
            const zoomPercent = Math.round(zoomLevel * 100);
            document.getElementById('zoom-level-display').textContent = zoomPercent + '%';

            // Update visible range display - compact format on one line
            // Calculate what's actually visible in the viewport (0 to innerWidth)
            // Reuse viewportWidth from above
            const startDate = newXScale.invert(0);
            const endDate = newXScale.invert(viewportWidth);

            // Format: "Oct 1 05:57 → Oct 9 20:50" - compact, always one line
            const formatCompact = (date) => {
                const month = date.toLocaleDateString('en-US', { month: 'short' });
                const day = date.getDate();
                const hours = String(date.getHours()).padStart(2, '0');
                const mins = String(date.getMinutes()).padStart(2, '0');
                return `${month} ${day} ${hours}:${mins}`;
            };

            const rangeText = `${formatCompact(startDate)} → ${formatCompact(endDate)}`;
            document.getElementById('visible-range-display').textContent = rangeText;

            // Update project count badge
            const visibleStartTs = startDate.getTime();
            const visibleEndTs = endDate.getTime();
            const visiblePrompts = prompts.filter(p => p.timestamp >= visibleStartTs && p.timestamp <= visibleEndTs);
            const projectsWithData = new Set(visiblePrompts.map(p => p.project || 'unknown'));
            const projectCount = projectsWithData.size;

            const badge = document.getElementById('project-count-badge');
            badge.textContent = projectCount;

            // Color based on thresholds
            if (projectCount < 12) {
                badge.style.background = '#27ae60'; // green
            } else if (projectCount <= 16) {
                badge.style.background = '#f39c12'; // orange
            } else {
                badge.style.background = '#e74c3c'; // red
            }

            // Auto-rerank after 500ms of inactivity (but not in selection mode)
            if (autoRerankTimeout) {
                clearTimeout(autoRerankTimeout);
            }
            if (!selectionMode) {
                autoRerankTimeout = setTimeout(() => {
                    // Check if rerank would actually change anything
                    const currentVisibleStartTs = startDate.getTime();
                    const currentVisibleEndTs = endDate.getTime();
                    const currentVisiblePrompts = prompts.filter(p => p.timestamp >= currentVisibleStartTs && p.timestamp <= currentVisibleEndTs);

                    // Group by project
                    const currentProjectGroups = {};
                    currentVisiblePrompts.forEach(prompt => {
                        const project = prompt.project || 'unknown';
                        if (!currentProjectGroups[project]) {
                            currentProjectGroups[project] = [];
                        }
                        currentProjectGroups[project].push(prompt);
                    });

                    // Get new order
                    const newProjectCounts = Object.keys(currentProjectGroups).map(project => ({
                        project: project,
                        count: currentProjectGroups[project].length
                    }));
                    newProjectCounts.sort((a, b) => {
                        if (b.count !== a.count) return b.count - a.count;
                        return a.project.localeCompare(b.project);
                    });
                    const newOrder = newProjectCounts.map(pc => pc.project);

                    // Check if order changed
                    const currentOrder = projects.slice(0, newOrder.length);
                    const orderChanged = newOrder.length !== currentOrder.length ||
                        newOrder.some((p, i) => p !== currentOrder[i]);

                    if (orderChanged) {
                        refreshTimeline();
                    }
                }, 500);
            }
        }

        function zoomIn() {
            svg.transition()
                .duration(300)
                .call(zoom.scaleBy, 1.5);
        }

        function zoomOut() {
            svg.transition()
                .duration(300)
                .call(zoom.scaleBy, 0.67);
        }

        function updateZoomDisplay() {
            const transform = d3.zoomTransform(svg.node());
            const zoomPercent = Math.round(transform.k * 100);
            document.getElementById('zoom-level-display').textContent = zoomPercent + '%';
        }

        function updateHiddenProjectsBadge() {
            // Count total projects with prompts vs displayed projects
            const totalProjects = Object.keys(projectGroups).length;
            const displayedProjects = projects.length;
            const hiddenCount = totalProjects - displayedProjects;

            const badge = document.getElementById('hidden-projects-badge');
            if (hiddenCount > 0) {
                badge.textContent = `+${hiddenCount}`;
                badge.style.display = 'inline';
                badge.title = `${hiddenCount} more project${hiddenCount > 1 ? 's' : ''} not shown - click Reorder to see them`;
            } else {
                badge.style.display = 'none';
            }
        }

        function filterByProject(project) {
            // Save viewport before filtering
            ViewportState.save();

            // SAFE VERSION: Don't touch viewport at all
            currentProjectFilter = project;

            // Just update which projects are visible
            const visibleProjectsToShow = project ? [project] : projects;

            const container = document.getElementById('timeline-scroll-container');
            const height = container.clientHeight;
            const innerHeight = height - margin.top - margin.bottom;
            const minProjectHeight = 35;
            const maxProjectHeight = innerHeight / Math.max(1, visibleProjectsToShow.length);
            const projectHeight = Math.max(minProjectHeight, maxProjectHeight);

            yScale.domain(visibleProjectsToShow).range([15, visibleProjectsToShow.length * projectHeight]);

            // Update y-axis
            const yAxisGroup = g.select('.y-axis');
            if (yAxisGroup.size() > 0) {
                yAxisGroup.call(d3.axisLeft(yScale));
            }

            // Update dots and track lines positions
            contentGroup.selectAll('.prompt-dot')
                .style('display', d => {
                    if (project && (d.project || 'unknown') !== project) return 'none';
                    return 'block';
                })
                .attr('cy', d => yScale(d.project || 'unknown') + yScale.bandwidth() / 2);

            contentGroup.selectAll('.track-line')
                .style('display', d => {
                    if (project && d !== project) return 'none';
                    return 'block';
                })
                .attr('y1', d => yScale(d) + yScale.bandwidth() / 2)
                .attr('y2', d => yScale(d) + yScale.bandwidth() / 2);

            // Restore viewport after filtering
            ViewportState.restore();
        }

        function refreshTimeline() {
            // Save viewport before any changes
            ViewportState.save();

            // SAFE VERSION: Only reorder projects, don't touch viewport at all
            const container = document.getElementById('timeline-scroll-container');
            const savedTransform = svg ? d3.zoomTransform(svg.node()) : d3.zoomIdentity;

            // Get visible time range from current viewport
            const currentXScale = savedTransform.rescaleX(xScale);
            const viewportWidth = container.clientWidth - margin.left - margin.right;
            const visibleStartDate = currentXScale.invert(0);
            const visibleEndDate = currentXScale.invert(viewportWidth);
            const visibleStartTs = visibleStartDate.getTime();
            const visibleEndTs = visibleEndDate.getTime();

            // Filter prompts to visible time range
            const visiblePrompts = prompts.filter(p =>
                p.timestamp >= visibleStartTs && p.timestamp <= visibleEndTs
            );

            // Group by project for visible prompts only
            const visibleProjectGroups = {};
            visiblePrompts.forEach(prompt => {
                const project = prompt.project || 'unknown';
                if (!visibleProjectGroups[project]) {
                    visibleProjectGroups[project] = [];
                }
                visibleProjectGroups[project].push(prompt);
            });

            // Get projects by count in visible range
            const visibleProjects = Object.keys(visibleProjectGroups);
            const projectCounts = visibleProjects.map(project => ({
                project: project,
                count: visibleProjectGroups[project].length
            }));

            // Sort by count descending, then by name
            projectCounts.sort((a, b) => {
                if (b.count !== a.count) return b.count - a.count;
                return a.project.localeCompare(b.project);
            });

            // Smart reranking: Preserve positions to minimize disruption
            const topN = 15; // How many to track
            const sorted = projectCounts.map(pc => pc.project);
            const newTopNSet = new Set(sorted.slice(0, topN));
            const prevTopNSet = new Set(projects.slice(0, topN));

            // Check if top N is the same (just different order within it)
            if (newTopNSet.size === prevTopNSet.size &&
                [...newTopNSet].every(p => prevTopNSet.has(p))) {
                console.log('Top N unchanged - no reorder needed');
                return;
            }

            // Build new order: preserve positions of projects still in top N
            const result = [];
            const used = new Set();

            // First pass: keep projects in their original position if still in top N
            for (let i = 0; i < topN; i++) {
                const prevProject = projects[i];
                if (prevProject && newTopNSet.has(prevProject)) {
                    result[i] = prevProject;
                    used.add(prevProject);
                }
            }

            // Second pass: fill empty slots with new projects (sorted by count)
            let sortedIndex = 0;
            for (let i = 0; i < topN; i++) {
                if (!result[i]) {
                    // Find next unused project from sorted list
                    while (sortedIndex < sorted.length && used.has(sorted[sortedIndex])) {
                        sortedIndex++;
                    }
                    if (sortedIndex < sorted.length) {
                        result[i] = sorted[sortedIndex];
                        used.add(sorted[sortedIndex]);
                        sortedIndex++;
                    }
                }
            }

            // Update order
            projects = result.filter(p => p); // Remove any undefined

            // Debug: log the ordering
            console.log('Reranked projects (most to least):', projectCounts.map(pc => `${pc.project}: ${pc.count}`));

            // Update project filter dropdown
            populateProjectFilter();

            // DON'T call initTimeline - that breaks everything
            // Instead, just update the y-scale domain and redraw
            const visibleProjectsToShow = currentProjectFilter ? [currentProjectFilter] : projects;
            const width = container.clientWidth;
            const height = container.clientHeight;
            const innerHeight = height - margin.top - margin.bottom;
            const minProjectHeight = 35;
            const maxProjectHeight = innerHeight / Math.max(1, visibleProjectsToShow.length);
            const projectHeight = Math.max(minProjectHeight, maxProjectHeight);

            yScale.domain(visibleProjectsToShow).range([15, visibleProjectsToShow.length * projectHeight]);

            // Recreate project labels to avoid overlapping
            g.selectAll('foreignObject').remove();

            visibleProjectsToShow.forEach(project => {
                const y = yScale(project) + yScale.bandwidth() / 2;
                const labelText = project.split('/').pop() || project;
                const labelWidth = 140;
                const labelHeight = yScale.bandwidth();

                const labelGroup = g.append('foreignObject')
                    .attr('x', -labelWidth - 5)
                    .attr('y', y - labelHeight / 2)
                    .attr('width', labelWidth)
                    .attr('height', labelHeight);

                labelGroup.append('xhtml:div')
                    .style('color', '#888')
                    .style('font-size', '11px')
                    .style('text-align', 'right')
                    .style('padding-right', '5px')
                    .style('white-space', 'nowrap')
                    .style('overflow', 'hidden')
                    .style('text-overflow', 'ellipsis')
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('justify-content', 'flex-end')
                    .style('height', '100%')
                    .text(labelText)
                    .attr('title', project);
            });

            // Update all visual elements with new y positions without changing x
            contentGroup.selectAll('.prompt-dot')
                .attr('cy', d => yScale(d.project || 'unknown') + yScale.bandwidth() / 2);

            contentGroup.selectAll('.track-line')
                .attr('y1', d => yScale(d) + yScale.bandwidth() / 2)
                .attr('y2', d => yScale(d) + yScale.bandwidth() / 2);

            // Restore viewport after reordering
            ViewportState.restore();
        }

        function showTooltip(event, d) {
            const tooltip = d3.select('#tooltip');
            const time = new Date(d.timestamp).toLocaleTimeString();
            const preview = d.display.length > 300 ?
                d.display.substring(0, 300) + '...' : d.display;

            tooltip.html(`
                <div class="tooltip-time">${time} • ${d.display.length} chars</div>
                <div class="tooltip-text">${escapeHtml(preview)}</div>
            `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY + 10) + 'px')
            .style('opacity', 1);
        }

        function hideTooltip() {
            d3.select('#tooltip').style('opacity', 0);
        }

        function changeDate(delta) {
            // Parse date as local time to avoid timezone issues
            const [year, month, day] = currentDate.split('-').map(Number);
            const date = new Date(year, month - 1, day);
            date.setDate(date.getDate() + delta);
            const newYear = date.getFullYear();
            const newMonth = String(date.getMonth() + 1).padStart(2, '0');
            const newDay = String(date.getDate()).padStart(2, '0');
            const newDate = `${newYear}-${newMonth}-${newDay}`;
            loadDate(newDate);
        }

        function onDateChange(newDate) {
            loadDate(newDate);
        }

        function loadDate(newDate) {
            currentDate = newDate;
            document.getElementById('date-input').value = newDate;
            alert(`To view ${newDate}, run:\n\nprompt-tracker timeline ${newDate}`);
        }

        function showPanel(event, prompt) {
            currentPrompt = prompt;
            const panel = document.getElementById('side-panel');
            const panelBody = document.getElementById('panel-body');

            const time = new Date(prompt.timestamp).toLocaleString();

            let html = `
                <div class="prompt-id">Prompt #${prompt.id} • ${prompt.display.length} characters</div>
                <div class="prompt-time">${time}</div>
                <div class="rating-selector">
                    ${[1,2,3,4,5].map(rating =>
                        `<span class="rating-star ${prompt.rating >= rating ? 'filled' : 'empty'}"
                               onclick="setRating(${prompt.id}, ${rating})"
                               data-rating="${rating}">★</span>`
                    ).join('')}
                </div>
                <div class="prompt-text">${escapeHtml(prompt.display)}</div>
            `;

            if (prompt.project) {
                html += `<div class="prompt-meta">Project: ${escapeHtml(prompt.project)}</div>`;
            }

            if (prompt.note) {
                html += `<div class="prompt-note"><strong>Note:</strong><br>${escapeHtml(prompt.note)}</div>`;
            }

            panelBody.innerHTML = html;
            panel.classList.add('active');
        }

        function setRating(promptId, rating) {
            const prompt = prompts.find(p => p.id === promptId);
            if (prompt) {
                prompt.rating = rating;

                // Update the dot
                d3.selectAll('.prompt-dot')
                    .filter(d => d.id === promptId)
                    .attr('class', `prompt-dot rating-${rating}`);

                // Update stars in panel
                document.querySelectorAll('.rating-star').forEach((star, index) => {
                    star.className = index < rating ? 'rating-star filled' : 'rating-star empty';
                });

                // Show save status
                const status = document.getElementById('save-status');
                status.classList.add('show');
                setTimeout(() => status.classList.remove('show'), 2000);

                saveRating(promptId, rating);
            }
        }

        function saveRating(promptId, rating) {
            // Save to server
            fetch('/api/rate', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    prompt_id: promptId,
                    rating: rating
                })
            }).then(response => {
                if (!response.ok) {
                    console.error('Failed to save rating');
                }
            }).catch(error => {
                console.error('Error saving rating:', error);
            });
        }

        function closePanel() {
            document.getElementById('side-panel').classList.remove('active');
            currentPrompt = null;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function toggleSelection() {
            selectionMode = !selectionMode;
            const btn = document.getElementById('select-btn');

            if (selectionMode) {
                btn.classList.add('active');
                btn.textContent = '✓ Selecting';
                setMode(MODES.SELECTION);
            } else {
                btn.classList.remove('active');
                btn.textContent = '⬚ Select';
                setMode(MODES.NORMAL);
                clearSelection();
            }
        }

        function brushEnded(event) {
            const selection = event.selection;
            if (!selection) return;

            selectedPrompts.clear();

            // Save current transform and scroll position
            const transform = d3.zoomTransform(svg.node());
            const container = document.getElementById('timeline-scroll-container');
            const savedScrollTop = container.scrollTop;
            const newXScale = transform.rescaleX(xScale);

            // Find dots within selection
            contentGroup.selectAll('.prompt-dot').each(function(d) {
                const cx = parseFloat(d3.select(this).attr('cx'));
                const cy = parseFloat(d3.select(this).attr('cy'));

                if (cx >= selection[0][0] && cx <= selection[1][0] &&
                    cy >= selection[0][1] && cy <= selection[1][1]) {
                    selectedPrompts.add(d.id);
                    d3.select(this).classed('selected', true);
                } else {
                    d3.select(this).classed('selected', false);
                }
            });

            // Clear the brush selection rectangle but keep the dots selected
            contentGroup.select('.brush').call(brush.move, null);

            // Don't touch viewport - scroll position is already correct from drag behavior
            updateSelectionUI();
        }

        function clearSelection() {
            selectedPrompts.clear();
            contentGroup.selectAll('.prompt-dot').classed('selected', false);
            updateSelectionUI();
        }

        function updateSelectionUI() {
            const count = selectedPrompts.size;
            const countEl = document.getElementById('selection-count');
            const exportBtn = document.getElementById('export-btn');
            const animateTheaterBtn = document.getElementById('animate-theater-btn');
            const animateCrawlBtn = document.getElementById('animate-crawl-btn');
            const animate10xBtn = document.getElementById('animate-10x-btn');

            if (count > 0) {
                countEl.textContent = `${count} selected`;
                countEl.style.display = 'inline';
                exportBtn.style.display = 'inline-block';
                animateTheaterBtn.style.display = 'inline-block';
                animateCrawlBtn.style.display = 'inline-block';
                animate10xBtn.style.display = 'inline-block';
            } else {
                countEl.style.display = 'none';
                exportBtn.style.display = 'none';
                animateTheaterBtn.style.display = 'none';
                animateCrawlBtn.style.display = 'none';
                animate10xBtn.style.display = 'none';
            }
        }

        function exportSelected() {
            if (selectedPrompts.size === 0) return;

            const selected = prompts.filter(p => selectedPrompts.has(p.id));

            // Sort by timestamp
            selected.sort((a, b) => a.timestamp - b.timestamp);

            // Create CSV
            const headers = ['ID', 'Timestamp', 'Time', 'Project', 'Rating', 'Prompt', 'Note'];
            const rows = [headers];

            selected.forEach(p => {
                const dt = new Date(p.timestamp);
                const timeStr = dt.toLocaleString();
                const rating = p.rating || '';
                const note = (p.note || '').replace(/"/g, '""');
                const prompt = p.display.replace(/"/g, '""');
                const project = (p.project || '').replace(/"/g, '""');

                rows.push([
                    p.id,
                    p.timestamp,
                    timeStr,
                    project,
                    rating,
                    `"${prompt}"`,
                    `"${note}"`
                ]);
            });

            const csv = rows.map(row => row.join(',')).join('\n');

            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `prompts_${currentDate}_${selectedPrompts.size}_selected.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function animateTheater() {
            if (selectedPrompts.size === 0) return;

            const selected = prompts.filter(p => selectedPrompts.has(p.id));
            selected.sort((a, b) => a.timestamp - b.timestamp);

            if (selected.length === 0) return;

            // Store prompts for navigation
            theaterPrompts = selected;
            theaterCurrentIndex = 0;
            theaterDuration = 120000;  // 2-minute mode

            // Enter theater mode
            const theaterMode = document.getElementById('theater-mode');
            theaterMode.classList.add('active');
            animationRunning = false;  // Don't auto-play

            // Initialize theater timeline
            initTheaterTimeline(selected);

            // Clear selection highlighting
            contentGroup.selectAll('.prompt-dot').classed('selected', false);

            // Show first prompt without auto-playing
            showTheaterPrompt(0);
        }

        function animate10x() {
            if (selectedPrompts.size === 0) return;

            const selected = prompts.filter(p => selectedPrompts.has(p.id));
            selected.sort((a, b) => a.timestamp - b.timestamp);

            if (selected.length === 0) return;

            // Store prompts for navigation
            theaterPrompts = selected;
            theaterCurrentIndex = 0;

            // Calculate 10x speed duration
            const firstTimestamp = selected[0].timestamp;
            const lastTimestamp = selected[selected.length - 1].timestamp;
            const actualDuration = lastTimestamp - firstTimestamp;
            theaterDuration = actualDuration / 10;

            // Enter theater mode
            const theaterMode = document.getElementById('theater-mode');
            theaterMode.classList.add('active');
            animationRunning = false;  // Don't auto-play

            // Initialize theater timeline
            initTheaterTimeline(selected);

            // Clear selection highlighting
            contentGroup.selectAll('.prompt-dot').classed('selected', false);

            // Show first prompt without auto-playing
            showTheaterPrompt(0);
        }

        function initTheaterTimeline(selected) {
            const container = document.getElementById('theater-timeline');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const theaterMargin = {top: 20, right: 40, bottom: 40, left: 80};

            // Clear existing
            d3.select('#theater-timeline').selectAll('*').remove();

            theaterSvg = d3.select('#theater-timeline')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            theaterG = theaterSvg.append('g')
                .attr('transform', `translate(${theaterMargin.left},${theaterMargin.top})`);

            const innerWidth = width - theaterMargin.left - theaterMargin.right;
            const innerHeight = height - theaterMargin.top - theaterMargin.bottom;

            // Add clip path
            theaterSvg.append('defs')
                .append('clipPath')
                .attr('id', 'theater-clip')
                .append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', innerWidth)
                .attr('height', innerHeight);

            theaterContentGroup = theaterG.append('g')
                .attr('clip-path', 'url(#theater-clip)');

            // Create time scale for selected prompts
            const [year, month, day] = currentDate.split('-').map(Number);
            const firstTime = new Date(selected[0].timestamp);
            const lastTime = new Date(selected[selected.length - 1].timestamp);

            const theaterXScale = d3.scaleTime()
                .domain([firstTime, lastTime])
                .range([0, innerWidth]);

            // Group by project
            const selectedProjects = [...new Set(selected.map(p => p.project || 'Unknown'))];
            const theaterYScale = d3.scaleBand()
                .domain(selectedProjects)
                .range([0, innerHeight])
                .padding(0.3);

            // Add project tracks
            selectedProjects.forEach(project => {
                const y = theaterYScale(project) + theaterYScale.bandwidth() / 2;

                theaterContentGroup.append('line')
                    .attr('class', 'track-line')
                    .attr('x1', 0)
                    .attr('x2', innerWidth)
                    .attr('y1', y)
                    .attr('y2', y)
                    .attr('stroke', projectColors[project] || '#666')
                    .attr('stroke-opacity', 0.3);

                const theaterLabel = theaterG.append('text')
                    .attr('class', 'track-label')
                    .attr('x', -10)
                    .attr('y', y)
                    .attr('text-anchor', 'end')
                    .attr('dominant-baseline', 'middle')
                    .style('fill', '#888')
                    .style('font-size', '11px')
                    .text(project.split('/').pop() || project);

                // Add hover tooltip with full path
                theaterLabel.append('title')
                    .text(project);
            });

            // Add axis
            theaterG.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${innerHeight})`)
                .style('color', '#666')
                .call(d3.axisBottom(theaterXScale)
                    .ticks(5)
                    .tickFormat(d3.timeFormat('%H:%M')));

            // Add dots (initially invisible)
            const maxLength = d3.max(selected, d => d.display.length) || 1000;
            const radiusScale = d3.scaleSqrt()
                .domain([0, maxLength])
                .range([4, 20]);

            theaterContentGroup.selectAll('.theater-dot')
                .data(selected)
                .enter()
                .append('circle')
                .attr('class', 'theater-dot')
                .attr('cx', d => theaterXScale(new Date(d.timestamp)))
                .attr('cy', d => {
                    const project = d.project || 'Unknown';
                    return theaterYScale(project) + theaterYScale.bandwidth() / 2;
                })
                .attr('r', d => radiusScale(d.display.length))
                .attr('fill', d => {
                    if (!d.rating) return '#666';
                    if (d.rating <= 2) return '#e74c3c';
                    if (d.rating === 3) return '#f39c12';
                    return '#27ae60';
                })
                .style('opacity', 0);

            return {theaterXScale, theaterYScale, innerWidth, innerHeight};
        }

        function playTheaterAnimation(selected, totalDuration) {
            const firstTimestamp = selected[0].timestamp;
            const lastTimestamp = selected[selected.length - 1].timestamp;
            const actualDuration = lastTimestamp - firstTimestamp;

            let currentIndex = 0;
            const startTime = Date.now();

            const promptDisplay = document.getElementById('theater-prompt');
            const promptTime = document.getElementById('theater-time');
            const promptProject = document.getElementById('theater-project');
            const promptText = document.getElementById('theater-text');
            const progressEl = document.getElementById('theater-progress');

            function animateNext() {
                if (!animationRunning || currentIndex >= selected.length) {
                    // Animation complete
                    promptDisplay.style.opacity = '0';
                    setTimeout(() => {
                        if (animationRunning) {
                            exitTheaterMode();
                        }
                    }, 1000);
                    return;
                }

                const prompt = selected[currentIndex];
                const elapsed = Date.now() - startTime;
                const progress = Math.min(100, (elapsed / totalDuration) * 100);

                // Update progress
                progressEl.textContent = `${currentIndex + 1} / ${selected.length} prompts • ${Math.round(progress)}%`;

                // Show the dot with dramatic effect
                const dot = theaterContentGroup.selectAll('.theater-dot')
                    .filter(d => d.id === prompt.id);

                dot.transition()
                    .duration(200)
                    .style('opacity', 0.3)
                    .transition()
                    .duration(300)
                    .style('opacity', 1)
                    .attr('r', function() {
                        return parseFloat(d3.select(this).attr('r')) * 1.5;
                    })
                    .transition()
                    .duration(400)
                    .attr('r', function() {
                        return parseFloat(d3.select(this).attr('r')) / 1.5;
                    });

                // Display prompt text above timeline
                const time = new Date(prompt.timestamp).toLocaleTimeString();
                promptTime.textContent = time;
                const projectName = prompt.project ? (prompt.project.split('/').pop() || prompt.project) : 'Unknown';
                promptProject.textContent = projectName;
                promptProject.title = prompt.project || 'Unknown';
                promptText.textContent = prompt.display;
                promptText.scrollTop = 0; // Reset scroll position

                promptDisplay.style.opacity = '1';

                // Create floating music note effect
                createFloatingNote(dot.node());

                // Calculate delay until next prompt
                currentIndex++;
                if (currentIndex < selected.length) {
                    const nextPrompt = selected[currentIndex];
                    const timeGap = nextPrompt.timestamp - prompt.timestamp;
                    const delay = (timeGap / actualDuration) * totalDuration;
                    setTimeout(animateNext, Math.max(300, delay));
                } else {
                    setTimeout(animateNext, 2000); // Show last prompt for 2 seconds
                }
            }

            animateNext();
        }

        function createFloatingNote(dotElement) {
            if (!dotElement) return;

            const bbox = dotElement.getBoundingClientRect();
            const theaterBox = document.getElementById('theater-timeline').getBoundingClientRect();

            const note = document.createElement('div');
            note.className = 'floating-note';
            note.textContent = '♪';

            // Random color from prompt rating colors
            const colors = ['#e74c3c', '#f39c12', '#27ae60', '#3b82f6'];
            note.style.color = colors[Math.floor(Math.random() * colors.length)];

            note.style.left = bbox.left + 'px';
            note.style.top = bbox.top + 'px';

            document.getElementById('theater-mode').appendChild(note);

            setTimeout(() => note.remove(), 2000);
        }

        function showTheaterPrompt(index) {
            if (index < 0 || index >= theaterPrompts.length) return;

            theaterCurrentIndex = index;
            const prompt = theaterPrompts[index];

            const promptDisplay = document.getElementById('theater-prompt');
            const promptTime = document.getElementById('theater-time');
            const promptProject = document.getElementById('theater-project');
            const promptText = document.getElementById('theater-text');
            const progressEl = document.getElementById('theater-progress');

            // Update display
            const time = new Date(prompt.timestamp).toLocaleTimeString();
            promptTime.textContent = time;
            const projectName = prompt.project ? (prompt.project.split('/').pop() || prompt.project) : 'Unknown';
            promptProject.textContent = projectName;
            promptProject.title = prompt.project || 'Unknown';
            promptText.textContent = prompt.display;
            promptText.scrollTop = 0; // Reset scroll position

            // Update progress
            progressEl.textContent = `${index + 1} / ${theaterPrompts.length} prompts`;

            // Update rating buttons
            const ratingButtons = document.querySelectorAll('.theater-rating-btn');
            ratingButtons.forEach((btn, i) => {
                if (prompt.rating && i + 1 === prompt.rating) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Show display
            promptDisplay.style.opacity = '1';

            // Highlight the dot
            theaterContentGroup.selectAll('.theater-dot')
                .style('opacity', d => d.id === prompt.id ? 1 : 0.3)
                .attr('r', d => {
                    const base = radiusScale(d.display.length);
                    return d.id === prompt.id ? base * 1.5 : base;
                });
        }

        function navigateTheaterPrompt(direction) {
            if (theaterPrompts.length === 0) return;

            const newIndex = theaterCurrentIndex + direction;
            if (newIndex >= 0 && newIndex < theaterPrompts.length) {
                showTheaterPrompt(newIndex);
            }
        }

        function rateTheaterPrompt(rating) {
            if (theaterPrompts.length === 0 || theaterCurrentIndex < 0) return;

            const prompt = theaterPrompts[theaterCurrentIndex];

            // Toggle off if clicking the same rating
            if (prompt.rating === rating) {
                rating = null;
            }

            // Update the prompt's rating
            prompt.rating = rating;

            // Find and update the prompt in the main prompts array
            const mainPrompt = prompts.find(p => p.id === prompt.id);
            if (mainPrompt) {
                mainPrompt.rating = rating;
            }

            // Send to server
            fetch('/api/rate', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    prompt_id: prompt.id,
                    rating: rating
                })
            });

            // Update rating button highlights
            const ratingButtons = document.querySelectorAll('.theater-rating-btn');
            ratingButtons.forEach((btn, i) => {
                if (rating && i + 1 === rating) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update the dot color in theater timeline
            theaterContentGroup.selectAll('.theater-dot')
                .filter(d => d.id === prompt.id)
                .attr('fill', () => {
                    if (!rating) return '#666';
                    if (rating <= 2) return '#e74c3c';
                    if (rating === 3) return '#f39c12';
                    return '#27ae60';
                });

            // Update in main timeline too
            contentGroup.selectAll('.prompt-dot')
                .filter(d => d.id === prompt.id)
                .attr('class', d => {
                    const classes = ['prompt-dot'];
                    if (rating) {
                        classes.push(`rating-${rating}`);
                    } else {
                        classes.push('unrated');
                    }
                    return classes.join(' ');
                });
        }

        function toggleTheaterAutoplay() {
            if (theaterPrompts.length === 0) return;

            if (animationRunning) {
                // Stop auto-play
                animationRunning = false;
            } else {
                // Start auto-play from current position
                animationRunning = true;

                // Start from current prompt instead of beginning
                const remainingPrompts = theaterPrompts.slice(theaterCurrentIndex);
                const firstTimestamp = theaterPrompts[theaterCurrentIndex].timestamp;
                const lastTimestamp = theaterPrompts[theaterPrompts.length - 1].timestamp;
                const remainingTime = lastTimestamp - firstTimestamp;

                // Adjust duration proportionally
                const adjustedDuration = (remainingTime / (theaterPrompts[theaterPrompts.length - 1].timestamp - theaterPrompts[0].timestamp)) * theaterDuration;

                playTheaterAnimationFrom(theaterCurrentIndex, adjustedDuration);
            }
        }

        function playTheaterAnimationFrom(startIndex, totalDuration) {
            const selected = theaterPrompts;
            const firstTimestamp = selected[startIndex].timestamp;
            const lastTimestamp = selected[selected.length - 1].timestamp;
            const actualDuration = lastTimestamp - firstTimestamp;

            let currentIndex = startIndex;
            const startTime = Date.now();

            const promptDisplay = document.getElementById('theater-prompt');
            const promptTime = document.getElementById('theater-time');
            const promptProject = document.getElementById('theater-project');
            const promptText = document.getElementById('theater-text');
            const progressEl = document.getElementById('theater-progress');

            function animateNext() {
                if (!animationRunning || currentIndex >= selected.length) {
                    // Animation complete
                    promptDisplay.style.opacity = '0';
                    setTimeout(() => {
                        if (animationRunning) {
                            animationRunning = false;
                        }
                    }, 1000);
                    return;
                }

                const prompt = selected[currentIndex];
                theaterCurrentIndex = currentIndex;
                const elapsed = Date.now() - startTime;
                const progress = Math.min(100, (elapsed / totalDuration) * 100);

                // Update progress
                progressEl.textContent = `${currentIndex + 1} / ${selected.length} prompts • ${Math.round(progress)}%`;

                // Show the dot with dramatic effect
                const dot = theaterContentGroup.selectAll('.theater-dot')
                    .filter(d => d.id === prompt.id);

                dot.transition()
                    .duration(200)
                    .style('opacity', 0.3)
                    .transition()
                    .duration(300)
                    .style('opacity', 1)
                    .attr('r', function() {
                        return parseFloat(d3.select(this).attr('r')) * 1.5;
                    })
                    .transition()
                    .duration(400)
                    .attr('r', function() {
                        return parseFloat(d3.select(this).attr('r')) / 1.5;
                    });

                // Display prompt text above timeline
                const time = new Date(prompt.timestamp).toLocaleTimeString();
                promptTime.textContent = time;
                const projectName = prompt.project ? (prompt.project.split('/').pop() || prompt.project) : 'Unknown';
                promptProject.textContent = projectName;
                promptProject.title = prompt.project || 'Unknown';
                promptText.textContent = prompt.display;
                promptText.scrollTop = 0; // Reset scroll position

                // Update rating buttons
                const ratingButtons = document.querySelectorAll('.theater-rating-btn');
                ratingButtons.forEach((btn, i) => {
                    if (prompt.rating && i + 1 === prompt.rating) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });

                promptDisplay.style.opacity = '1';

                // Highlight current dot
                theaterContentGroup.selectAll('.theater-dot')
                    .style('opacity', d => d.id === prompt.id ? 1 : 0.3)
                    .attr('r', d => {
                        const base = radiusScale(d.display.length);
                        return d.id === prompt.id ? base * 1.5 : base;
                    });

                // Create floating music note effect
                createFloatingNote(dot.node());

                // Calculate delay until next prompt
                currentIndex++;
                if (currentIndex < selected.length) {
                    const nextPrompt = selected[currentIndex];
                    const timeGap = nextPrompt.timestamp - prompt.timestamp;
                    const delay = (timeGap / actualDuration) * totalDuration;
                    setTimeout(animateNext, Math.max(300, delay));
                } else {
                    setTimeout(animateNext, 2000); // Show last prompt for 2 seconds
                }
            }

            animateNext();
        }

        function showPromptInTheater(clickedPrompt) {
            // Sort all prompts by timestamp
            const sortedPrompts = [...prompts].sort((a, b) => a.timestamp - b.timestamp);

            // Find the index of the clicked prompt
            const clickedIndex = sortedPrompts.findIndex(p => p.id === clickedPrompt.id);
            if (clickedIndex === -1) return;

            // Set up theater mode with all prompts
            theaterPrompts = sortedPrompts;
            theaterCurrentIndex = clickedIndex;

            // Enter theater mode
            const theaterMode = document.getElementById('theater-mode');
            theaterMode.classList.add('active');
            animationRunning = true;

            // Show the clicked prompt
            showTheaterPrompt(clickedIndex);
        }

        function exitTheaterMode() {
            animationRunning = false;
            const theaterMode = document.getElementById('theater-mode');
            theaterMode.classList.remove('active');

            // Cleanup
            d3.select('#theater-timeline').selectAll('*').remove();

            // Turn off selection mode
            if (selectionMode) {
                selectionMode = false;
                const btn = document.getElementById('select-btn');
                btn.classList.remove('active');
                btn.textContent = '⬚ Select';
                disableBrush();
            }

            // Restore main timeline
            selectedPrompts.clear();
            contentGroup.selectAll('.prompt-dot').classed('selected', false);

            // Update dots to reflect any rating changes made in theater mode
            contentGroup.selectAll('.prompt-dot')
                .attr('class', d => {
                    const classes = ['prompt-dot'];
                    if (d.rating) {
                        classes.push(`rating-${d.rating}`);
                    } else {
                        classes.push('unrated');
                    }
                    if (selectedPrompts.has(d.id)) {
                        classes.push('selected');
                    }
                    return classes.join(' ');
                });

            updateSelectionUI();
        }

        function animateCrawl() {
            if (selectedPrompts.size === 0) return;

            const selected = prompts.filter(p => selectedPrompts.has(p.id));
            selected.sort((a, b) => a.timestamp - b.timestamp);

            if (selected.length === 0) return;

            // Store for navigation
            window.crawlPrompts = selected;
            window.crawlCurrentIndex = 0;

            // Enter crawl mode
            const crawlMode = document.getElementById('crawl-mode');
            crawlMode.classList.add('active');

            // Start starfield
            initStarfield();

            // Build scrollable list
            const crawlText = document.getElementById('crawl-text');
            crawlText.innerHTML = '';

            selected.forEach((prompt, index) => {
                const promptDiv = document.createElement('div');
                promptDiv.className = 'crawl-prompt';
                promptDiv.dataset.index = index;
                promptDiv.dataset.promptId = prompt.id;

                const meta = document.createElement('div');
                meta.className = 'crawl-prompt-meta';
                const time = new Date(prompt.timestamp).toLocaleTimeString('en-US', { 
                    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false 
                });
                meta.textContent = time;

                const text = document.createElement('div');
                text.className = 'crawl-prompt-text';
                text.textContent = prompt.display;

                const rating = document.createElement('div');
                rating.className = 'crawl-prompt-rating';
                rating.innerHTML = [1,2,3,4,5].map(r => 
                    `<span class="crawl-rating-star ${prompt.rating >= r ? 'filled' : 'empty'}" 
                           onclick="rateCrawlPrompt(${prompt.id}, ${r})"
                           data-rating="${r}">★</span>`
                ).join('');

                promptDiv.appendChild(meta);
                promptDiv.appendChild(text);
                promptDiv.appendChild(rating);
                
                promptDiv.onclick = function(e) {
                    if (!e.target.classList.contains('crawl-rating-star')) {
                        highlightCrawlPrompt(index);
                    }
                };

                crawlText.appendChild(promptDiv);
            });

            // Clear selection highlighting
            contentGroup.selectAll('.prompt-dot').classed('selected', false);
            updateSelectionUI();

            // Highlight the first prompt by default
            if (window.crawlPrompts && window.crawlPrompts.length > 0) {
                highlightCrawlPrompt(0);
            }

            // Sync highlight with mouse scroll position
            setupCrawlScrollSync();
        }

        let starfieldAnimationId;
        let crawlClockInterval;

        function updateCrawlClock() {
            const clockEl = document.getElementById('crawl-clock');

            function updateTime() {
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                clockEl.textContent = `${hours}:${minutes}:${seconds}`;
            }

            updateTime();
            crawlClockInterval = setInterval(updateTime, 1000);
        }

        // Keep track of scroll listener to clean up on exit
        let crawlScrollListener;
        let suppressCrawlScroll = false;
        let crawlSyncTicking = false; // rAF throttle for scroll sync

        function setupCrawlScrollSync() {
            // Remove any existing listener first
            const container = document.querySelector('.crawl-container');
            if (!container) return;
            if (crawlScrollListener) {
                container.removeEventListener('scroll', crawlScrollListener);
            }

            // Compute which prompt is closest to the vertical center on scroll
            crawlScrollListener = function() {
                if (!document.getElementById('crawl-mode').classList.contains('active')) return;
                if (crawlSyncTicking) return;
                crawlSyncTicking = true;
                requestAnimationFrame(() => {
                    crawlSyncTicking = false;
                    const promptsEls = Array.from(document.querySelectorAll('.crawl-prompt'));
                    if (promptsEls.length === 0) return;

                    // Use container center instead of window for robustness
                    const containerRect = container.getBoundingClientRect();
                    const viewportCenter = containerRect.top + containerRect.height / 2;
                    let closestIdx = 0;
                    let closestDist = Infinity;

                    for (let i = 0; i < promptsEls.length; i++) {
                        const rect = promptsEls[i].getBoundingClientRect();
                        const elCenter = rect.top + rect.height / 2;
                        const dist = Math.abs(elCenter - viewportCenter);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestIdx = i;
                        }
                    }

                    if (closestIdx !== window.crawlCurrentIndex) {
                        suppressCrawlScroll = true;
                        highlightCrawlPrompt(closestIdx);
                        suppressCrawlScroll = false;
                    }
                });
            };

            container.addEventListener('scroll', crawlScrollListener, { passive: true });
        }

        function initStarfield() {
            const canvas = document.getElementById('starfield');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Create stars
            const stars = [];
            const numStars = 200;

            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5,
                    opacity: Math.random(),
                    speed: Math.random() * 0.5 + 0.1
                });
            }

            function animate() {
                if (!animationRunning) return;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                stars.forEach(star => {
                    // Twinkle effect
                    star.opacity += (Math.random() - 0.5) * 0.02;
                    star.opacity = Math.max(0.3, Math.min(1, star.opacity));

                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.fill();

                    // Slow drift
                    star.y += star.speed;
                    if (star.y > canvas.height) {
                        star.y = 0;
                        star.x = Math.random() * canvas.width;
                    }
                });

                starfieldAnimationId = requestAnimationFrame(animate);
            }

            // Fill canvas with black initially
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            animate();
        }

        function renderCrawlClockFor(index) {
            const clockEl = document.getElementById('crawl-clock');
            if (!window.crawlPrompts || !window.crawlPrompts[index]) {
                clockEl.textContent = '';
                return;
            }
            const t = new Date(window.crawlPrompts[index].timestamp);
            const hours = String(t.getHours()).padStart(2, '0');
            const minutes = String(t.getMinutes()).padStart(2, '0');
            const seconds = String(t.getSeconds()).padStart(2, '0');
            clockEl.textContent = `${hours}:${minutes}:${seconds}`;
        }

        function highlightCrawlPrompt(index) {
            window.crawlCurrentIndex = index;
            document.querySelectorAll('.crawl-prompt').forEach((el, i) => {
                if (i === index) {
                    el.classList.add('highlighted');
                    if (!suppressCrawlScroll) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else {
                    el.classList.remove('highlighted');
                }
            });
            // Show the highlighted prompt's time on the clock
            renderCrawlClockFor(index);
        }

        function rateCrawlPrompt(promptId, rating) {
            const prompt = prompts.find(p => p.id === promptId);
            if (!prompt) return;

            // Toggle off if same rating
            if (prompt.rating === rating) {
                rating = null;
            }

            prompt.rating = rating;

            // Update stars in crawl view
            const promptDiv = document.querySelector(`[data-prompt-id="${promptId}"]`);
            if (promptDiv) {
                promptDiv.querySelectorAll('.crawl-rating-star').forEach((star, i) => {
                    star.className = (rating && i < rating) ? 'crawl-rating-star filled' : 'crawl-rating-star empty';
                });
            }

            // Save to localStorage
            const ratings = JSON.parse(localStorage.getItem('prompt_ratings') || '{}');
            if (rating === null) {
                delete ratings[promptId];
            } else {
                ratings[promptId] = rating;
            }
            localStorage.setItem('prompt_ratings', JSON.stringify(ratings));

            // Update main timeline
            contentGroup.selectAll('.prompt-dot')
                .filter(d => d.id === promptId)
                .attr('class', d => {
                    const classes = ['prompt-dot'];
                    if (rating) {
                        classes.push(`rating-${rating}`);
                    } else {
                        classes.push('unrated');
                    }
                    return classes.join(' ');
                });
        }

        function navigateCrawl(direction) {
            if (!window.crawlPrompts || window.crawlPrompts.length === 0) return;
            
            const newIndex = window.crawlCurrentIndex + direction;
            if (newIndex >= 0 && newIndex < window.crawlPrompts.length) {
                highlightCrawlPrompt(newIndex);
            }
        }

        function exitCrawlMode() {
            animationRunning = false;
            const crawlMode = document.getElementById('crawl-mode');
            crawlMode.classList.remove('active');

            // Stop starfield animation
            if (starfieldAnimationId) {
                cancelAnimationFrame(starfieldAnimationId);
            }

            // Stop clock
            if (crawlClockInterval) {
                clearInterval(crawlClockInterval);
            }

            // Clear crawl text
            document.getElementById('crawl-text').innerHTML = '';

            // Remove scroll sync listener
            const container = document.querySelector('.crawl-container');
            if (container && crawlScrollListener) {
                container.removeEventListener('scroll', crawlScrollListener);
                crawlScrollListener = undefined;
            }

            // Restore main timeline
            selectedPrompts.clear();
            contentGroup.selectAll('.prompt-dot').classed('selected', false);
            updateSelectionUI();
        }

        // Initialize
        initTimeline();

        // No filtering - showing all projects and prompts

        // Handle window resize - preserve viewport
        window.addEventListener('resize', () => {
            ViewportState.save();
            initTimeline(true); // Skip initial transform
            ViewportState.restore();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts if typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            // Check if in theater mode for arrow key navigation
            const inTheaterMode = document.getElementById('theater-mode').classList.contains('active');
            const inCrawlMode = document.getElementById('crawl-mode').classList.contains('active');

            // Arrow key panning on timeline (when not in theater/crawl mode)
            if (!inTheaterMode && !inCrawlMode) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (svg && zoom) {
                        const transform = d3.zoomTransform(svg.node());
                        const panAmount = (e.key === 'ArrowRight' ? -200 : 200) * transform.k;
                        const newTransform = d3.zoomIdentity
                            .translate(transform.x + panAmount, 0)
                            .scale(transform.k);
                        svg.call(zoom.transform, newTransform);
                    }
                    return;
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    const container = document.getElementById('timeline-scroll-container');
                    const scrollAmount = 200;
                    container.scrollTop += e.key === 'ArrowDown' ? scrollAmount : -scrollAmount;
                    return;
                }
            }

            // 's' key to toggle selection mode
            if (!inTheaterMode && !inCrawlMode && (e.key === 's' || e.key === 'S')) {
                e.preventDefault();
                toggleSelection();
                return;
            }

            if (e.key === 'Escape') {
                // Check if in crawl mode
                if (document.getElementById('crawl-mode').classList.contains('active')) {
                    exitCrawlMode();
                } else if (inTheaterMode) {
                    exitTheaterMode();
                } else {
                    closePanel();
                    if (selectionMode) {
                        toggleSelection();
                    }
                }
            } else if (inTheaterMode && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                // Navigate between prompts in theater mode
                e.preventDefault();
                animationRunning = false; // Stop automatic animation
                const direction = e.key === 'ArrowRight' ? 1 : -1;
                navigateTheaterPrompt(direction);
            } else if (document.getElementById('crawl-mode').classList.contains('active') && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                // Navigate in crawl mode
                e.preventDefault();
                const direction = e.key === 'ArrowDown' ? 1 : -1;
                navigateCrawl(direction);
            } else if (document.getElementById('crawl-mode').classList.contains('active') && ['1', '2', '3', '4', '5'].includes(e.key)) {
                // Rate in crawl mode
                e.preventDefault();
                if (window.crawlPrompts && window.crawlPrompts[window.crawlCurrentIndex]) {
                    rateCrawlPrompt(window.crawlPrompts[window.crawlCurrentIndex].id, parseInt(e.key));
                }
            } else if (inTheaterMode && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                // Scroll the prompt text in theater mode
                e.preventDefault();
                const promptText = document.getElementById('theater-text');
                const scrollAmount = 50;
                promptText.scrollTop += e.key === 'ArrowDown' ? scrollAmount : -scrollAmount;
            } else if (inTheaterMode && ['1', '2', '3', '4', '5'].includes(e.key)) {
                // Rate prompt in theater mode
                e.preventDefault();
                rateTheaterPrompt(parseInt(e.key));
            } else if (inTheaterMode && e.key === ' ') {
                // Toggle auto-play in theater mode
                e.preventDefault();
                toggleTheaterAutoplay();
            } else if (e.key === '+' || e.key === '=') {
                e.preventDefault();
                zoomIn();
            } else if (e.key === '-' || e.key === '_') {
                e.preventDefault();
                zoomOut();
            }
        });

        // Calendar functionality
        let calendarYear = new Date().getFullYear();
        let calendarMonth = new Date().getMonth();
        let promptCountsByDate = {};

        function showCalendar() {
            // Calculate prompt counts by date
            calculatePromptCountsByDate();

            // Set to current date
            const today = new Date();
            calendarYear = today.getFullYear();
            calendarMonth = today.getMonth();

            // Render and show calendar
            renderCalendar();
            document.getElementById('calendar-view').classList.add('active');
        }

        function closeCalendar() {
            document.getElementById('calendar-view').classList.remove('active');
        }

        function changeCalendarMonth(delta) {
            calendarMonth += delta;
            if (calendarMonth > 11) {
                calendarMonth = 0;
                calendarYear++;
            } else if (calendarMonth < 0) {
                calendarMonth = 11;
                calendarYear--;
            }
            renderCalendar();
        }

        function calculatePromptCountsByDate() {
            promptCountsByDate = {};
            prompts.forEach(p => {
                const date = new Date(p.timestamp);
                const dateStr = date.toISOString().split('T')[0];
                promptCountsByDate[dateStr] = (promptCountsByDate[dateStr] || 0) + 1;
            });
        }

        function renderCalendar() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                               'July', 'August', 'September', 'October', 'November', 'December'];
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            // Update month/year display
            document.getElementById('calendar-month-year').textContent =
                `${monthNames[calendarMonth]} ${calendarYear}`;

            // Get first and last day of month
            const firstDay = new Date(calendarYear, calendarMonth, 1);
            const lastDay = new Date(calendarYear, calendarMonth + 1, 0);

            // Get starting day offset
            const startOffset = firstDay.getDay();

            // Calculate previous month dates to fill in
            const prevMonthLastDay = new Date(calendarYear, calendarMonth, 0).getDate();

            // Build calendar grid
            const grid = document.getElementById('calendar-grid');
            grid.innerHTML = '';

            // Add day headers
            dayNames.forEach(day => {
                const header = document.createElement('div');
                header.className = 'calendar-day-header';
                header.textContent = day;
                grid.appendChild(header);
            });

            // Add previous month days
            for (let i = startOffset - 1; i >= 0; i--) {
                const day = prevMonthLastDay - i;
                const prevMonth = calendarMonth === 0 ? 11 : calendarMonth - 1;
                const prevYear = calendarMonth === 0 ? calendarYear - 1 : calendarYear;
                addDayCell(grid, day, prevMonth, prevYear, true);
            }

            // Add current month days
            for (let day = 1; day <= lastDay.getDate(); day++) {
                addDayCell(grid, day, calendarMonth, calendarYear, false);
            }

            // Add next month days to fill the grid
            const cellsUsed = startOffset + lastDay.getDate();
            const remainingCells = Math.ceil(cellsUsed / 7) * 7 - cellsUsed;
            for (let day = 1; day <= remainingCells; day++) {
                const nextMonth = calendarMonth === 11 ? 0 : calendarMonth + 1;
                const nextYear = calendarMonth === 11 ? calendarYear + 1 : calendarYear;
                addDayCell(grid, day, nextMonth, nextYear, true);
            }
        }

        function addDayCell(grid, day, month, year, isOtherMonth) {
            const cell = document.createElement('div');
            cell.className = 'calendar-day';

            if (isOtherMonth) {
                cell.classList.add('other-month');
            }

            // Check if today
            const today = new Date();
            if (day === today.getDate() && month === today.getMonth() && year === today.getFullYear()) {
                cell.classList.add('today');
            }

            // Get date string
            const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            const promptCount = promptCountsByDate[dateStr] || 0;

            // Set background color based on prompt density
            if (promptCount > 0) {
                const maxCount = Math.max(...Object.values(promptCountsByDate));
                const opacity = Math.min(1, Math.max(0.3, promptCount / maxCount));
                cell.style.background = `rgba(249, 115, 22, ${opacity})`;
            }

            // Add content
            const dayNumber = document.createElement('div');
            dayNumber.className = 'calendar-day-number';
            dayNumber.textContent = day;
            cell.appendChild(dayNumber);

            if (promptCount > 0) {
                const countLabel = document.createElement('div');
                countLabel.className = 'calendar-day-count';
                countLabel.textContent = `${promptCount} prompt${promptCount !== 1 ? 's' : ''}`;
                cell.appendChild(countLabel);
            }

            // Add click handler
            cell.addEventListener('click', () => {
                if (promptCount > 0) {
                    closeCalendar();
                    loadDate(dateStr);
                }
            });

            // Add hover handler for tooltip
            cell.title = `${dateStr}: ${promptCount} prompt${promptCount !== 1 ? 's' : ''}`;

            grid.appendChild(cell);
        }
    </script>
</body>
</html>
